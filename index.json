[{"content":"Class Nedir? JavaScript prototip tabanlı bir dildir ve javascript\u0026rsquo;teki her nesnenin, nesne özelliklerini ve yöntemlerini genişletmek için kullanılabilecek [[Prototype]] adlı gizli bir dahili özelliği vardır.\nJavaScript geliştiricileri, object-orianted design pattern (nesne yönelimli bir tasarım modeli) taklit etmek için constructor fonksiyonlarını kullandılar.\nES6 yani EcmaScript 2015 ile birlikte Class\u0026rsquo;ları JavaScript\u0026rsquo;de kullanabilir hale geldik. Aslında zaten JavaScript\u0026rsquo;de var olan Class yapısını getirme sebeplerinden başlıcası diğer dillerin çoğunun sahip olması ve temiz, düzenli kod yazılmasını mümkün kılması.\nModule Design Pattern\u0026rsquo;i Anlamak JavaScript\u0026rsquo;de modüller belirli kod parçalarını diğer bileşenlerden bağımsız tutmak için kullanılır. Public (herkese açık) veya Private (gizli) olarak erişim seviyeleri belirlenebilir.\nModüller\u0026rsquo;de özel kapsamları kullanabilmek için Immediately-Invoked-Function-Expressions (IIFE - hemen çağırılan fonksiyon) olarak tanımlanmalıdır.\nImmediately-Invoked-Function-Expressions Nedir? Adından da anlaşılabileceği gibi fonksiyonun daha sonra çağırılması yerine tanımlanırken çağırılmasıdır.\nNormal IIFE function foo(){ return console.log(\u0026#39;bar\u0026#39;) } foo() (function(){ return console.log(\u0026#39;bar\u0026#39;) })() IIFE ile çağırılan fonksiyonların içerisindeki değişkenler dış dünya tarafında görülmez ve ulaşılamaz. Bu sayede özel kapsamlar kullanılabilir. Bir kere çalışıcak kodlar için kullanılmalıdır ve global yerine yerel değişkenlerle çalışacağı için kod performans açısından daha hızlı olur.\nModule Design Pattern\u0026rsquo;i Örnekleri IIFE\u0026rsquo;yi de anladığımıza göre örneklere geçebiliriz. Temel yapı olarak şu şekildedir;\n(function() { // private değişkenler veya fonksiyonlar tanımlanır return { // public değişken veya fonksiyonlar tanımlanır } })(); Yukarıdaki fonksiyon ile private ve public verilerimizi tanımlayabilriz. Şimdi biraz daha realistik örnek verelim.\nvar EmployeeDetails = (function(){ var name: \u0026#34;Ömer Faruk\u0026#34;; var age = 19; var designation = \u0026#34;Developer\u0026#34;, var salary = 10000; var calculateBonus = function(amount) { salary = salary + amount; } return { name: name, age: age, designation: designation, calculateBonus: calculateBonus } })() var userName = EmployeeDetails.calculateBonus(1000); Bu örneğe bakıcak olursak salary değişkeninin fonksiyonda kullanıldığını fakat return edilmediği için dışarıdan ulaşılamayacağını görebilirsiniz. calculateBonus fonksiyonunda ikramiyeyi hesaplarken salary değişkeni kullanılmaktadır. Bu değişken return edilmeyip private olarak tanımlandığı için dışarıdan erişilemez fakat fonksiyon içerisinde kullanılmaya devam edebilir.\nDikkat! Public edilen değişkenlerin bir kopyası oluşur ve bunlar dışarıya sunulur. Eğerki değişken sonradan değişicek olsa bile ilk halindeki klonuna dışarıdan ulaşırız. Değişkenlerin değerlerinin değiştirilmesi vya okunması için get veya set metodları kullanılmalıdır.\nClass\u0026rsquo;lar Aslında Fonksiyon! Şimdi bir sürü bilgi öğrendik fakat konunun daha iyi anlaşılabilmesi için gerekliydi. Yukarıdaki kodlara baktığınızda bir şeyi anımsatıyor mu? Class\u0026rsquo;lar. Class dediğimiz yapı aslında bir fonksiyondur ve Class tanımladığınız zaman aslında bir fonksiyon tanımlamış oluyorsunuz. Gelin şimdi inceleyelim;\nconst x = function() {} const y = class {} console.log(typeof x); // function console.log(typeof y); // function Yukarıdaki örnekte görebileceğiniz gibi ikisininde çeşidi aynı ve function.\nClass\u0026rsquo;ların Tanımlanması Class\u0026rsquo;lar birer fonksiyon ise Class\u0026rsquo;lar ile yapabildiğimiz her şeyi fonksiyonlar ile de yapabilmemiz gerekir. Class\u0026rsquo;larda kullandığımız özelliklerin fonksiyonlarda nasıl tanımlandığını inceleyelim.\nConstructor Class\u0026rsquo;ı çağırırken çalışan ve değişken tanımlamamızı sağlayan constructor fonksiyonunun nasıl çalıştığına bir bakalım;\nClass Fonksiyon class Hero { constructor(name, level) { this.name = name; this.level = level; } } function Hero(name, level) { this.name = name; this.level = level; } Metodlar Class\u0026rsquo;ların içerisinde tanımladığımız metodların fonksiyonlar ile nasıl tanımlandığına da bakalım;\nClass Fonksiyon class Hero { constructor(name, level) { this.name = name; this.level = level; } hi() { return `${this.name} merhaba diyor.`; } } function Hero(name, level) { this.name = name; this.level = level; } Hero.prototype.hi = function() { return `${this.name} merhaba diyor.`; } Extend Class\u0026rsquo;ların ve fonksiyonların avantajlı bir özelliği, üst öğeye dayalı olarak yeni bir nesne olarak geliştirilebilmesidir. Bu, benzer ancak bazı ek veya daha spesifik özelliklere ihtiyaç duyan nesneler için kodun tekrarlanmasını önler.\nAşağıdaki örnekte, SuperHero adlı daha spesifik bir Hero oluşturacağız ve call() kullanarak Hero özelliklerini atayacağız ve ek bir özellik ekleyeceğiz.\nClass Fonksiyon class SuperHero extends Hero { constructor(name, level, spell) { // Hero Class\u0026#39;ının constructorunu çağırma super(name, level); // Yeni özelliği ekle this.spell = spell; } } const ironman = new SuperHero(\u0026#39;Tony Stark\u0026#39;, 2, \u0026#39;Money\u0026#39;); function SuperHero(name, level, spell) { // Hero fonksiyonunun constructorunu çağırma Hero.call(this, name, level); // Yeni özelliği ekle this.spell = spell; } const superman = new SuperHero(\u0026#39;Clark Kent\u0026#39;, 9999, \u0026#39;Unlimited Power\u0026#39;); Kapanış Bu yazıda Class\u0026rsquo;lar ve fonksiyonların benzerliğini ve nasıl çalıştığını öğrenmiş olduk. Nasıl çalıştığını anlamak bir dilde uzmanlaşmak için çok önemlidir. Daha fazlası için takipte kalabilir, eğer yazıda eksik veya hata gördüyseniz Github üzerinden düzenleyebilirsiniz.\n","permalink":"https://omerfarukdemirel.com.tr/post/javascriptde-classlar-gercek-midir/","summary":"Class Nedir? JavaScript prototip tabanlı bir dildir ve javascript\u0026rsquo;teki her nesnenin, nesne özelliklerini ve yöntemlerini genişletmek için kullanılabilecek [[Prototype]] adlı gizli bir dahili özelliği vardır.\nJavaScript geliştiricileri, object-orianted design pattern (nesne yönelimli bir tasarım modeli) taklit etmek için constructor fonksiyonlarını kullandılar.\nES6 yani EcmaScript 2015 ile birlikte Class\u0026rsquo;ları JavaScript\u0026rsquo;de kullanabilir hale geldik. Aslında zaten JavaScript\u0026rsquo;de var olan Class yapısını getirme sebeplerinden başlıcası diğer dillerin çoğunun sahip olması ve temiz, düzenli kod yazılmasını mümkün kılması.","title":"Javascript'de Class'lar Gerçek Midir?"},{"content":"Binary Search Nedir? Binary Search her türlü dataset ile çalışabilen ve içerisindeki verinin indexini bulmamızı sağlayan akıllı bir algoritmadır.\nBüyük dizilerde doğrdan tek-tek yapılan kontrolden daha hızlı çalışır fakat dizinin küçükten büyüğe veya büyükten küçüğe doğru sıralı olması zorunludur, aksi halde çalışmayacaktır.\nBinary Search Nasıl Çalışır? Binary search her bir işlemde arama uzayını yarı yarıya indirmek üzerinde kuruludur. Temel mantığı şu şekildedir;\nDizinin tam orasında bulunan veriyi seçer ve bu veri üzerinden kontrol yapar. 3 farklı durum vardır; Seçilen değer aradığımız değere eşit ise aradığımız değer bulunmuştur. Değer geri döndürülür ve algoritma biter. Seçilen değer aradığımız değerden daha küçük ise aradığımız değer, seçtiğimiz verinin sol tarafındadır. Seçilen değer aradığımız değerden daha büyük ise aradığımız değer, seçtiğimiz verinin sağ tarafındadır. Yukarıdaki 2. veya 3. seçenekten biri gerçekleşmiş ise kümemizin diğer kısmını sileriz ve yarıya indirmiş oluruz. Ardından 1. adımı tekrardan uygularız ve aradığımız değeri bulana kadar devam ederiz. Aşağıdaki örnekte tek-tek yapılan kontrole kıyasla ne kadar hızlı olduğunu görebilirsiniz.\nŞimdi daha iyi anlamak için örnek yapacak olursak [-3,2,4,,4,9,12,34,42,102,157,180]\u0026lsquo;den oluşan veri setinden 42 sayısını bulmaya çalışalım;\n-3 2 4 4 9 12 34 42 102 157 180 -3 2 4 4 9 12 34 42 102 157 180 -3 2 4 4 9 12 34 42 102 157 180 -3 2 4 4 9 12 34 42 102 157 180 Kodlama Kodlamaya başlamadan önce aşağıdaki işlemleri bilmemiz gerekmektedir;\nZaman Karmaşıklığı: O(log n) Yardımcı Alan: O(1) Ortanca Değeri Bulma: en_yuksek + ( en_dusuk + en_yuksek ) / 2 Son maddede neden en_yuksek değer ile topladığımızı merak ediyor olabilirsiniz. Direkt olarak ( en_dusuk + en_yuksek ) / 2 de yapabilirdik fakat bu 100% doğruluk oranı vermeyecektir. Çünkü en düşük ve en yüksek değerlerden daha büyük değerleri aldığımızda başarısız olacaktır. Özellikle en düşük ve en yüksek değerin toplamı datasetimizdeki maximum pozitif değerden büyükse başarısız olacaktır. Sonuçta toplam değer negatif olur ve 2\u0026rsquo;ye bölündüğünde negatif olarak kalır.\nRecursive Python Javascript # X\u0026#39;in indexini döndürür, yoksa -1 döndürür def binarySearch(arr, l, r, x): # Temeli kontrol et if r \u0026gt;= l: mid = l + (r - l) // 2 # Eğer eleman ortada mevcutsa # kendine eşittir if arr[mid] == x: return mid # Eğer element ortanca değerden küçükse # sadece sol tarafta olabilir elif arr[mid] \u0026gt; x: return binarySearch(arr, l, mid-1, x) # Bunun dışındaki durumlarda # sadece sağ tarafta olabilir else: return binarySearch(arr, mid + 1, r, x) else: # Element dizide yoktur return -1 # Tanımlamalar arr = [2, 3, 4, 10, 40] x = 10 # Fonksiyonu çağırma result = binarySearch(arr, 0, len(arr)-1, x) if result != -1: print(\u0026#34;Element dizinde %d. sırada mevcut\u0026#34; % result) else: print(\u0026#34;Element dizide değildir\u0026#34;) // X\u0026#39;in indexini döndürür, yoksa -1 döndürür function binarySearch(arr, l, r, x){ if (r \u0026gt;= l) { let mid = l + Math.floor((r - l) / 2); // Eğer eleman ortada mevcutsa // kendine eşittir if (arr[mid] == x) return mid; // Eğer element ortanca değerden küçükse // sadece sol tarafta olabilir if (arr[mid] \u0026gt; x) return binarySearch(arr, l, mid - 1, x); // Bunun dışındaki durumlarda // sadece sağ tarafta olabilir return binarySearch(arr, mid + 1, r, x); } // Element dizide yoktur return -1; } let arr = [ 2, 3, 4, 10, 40 ]; let x = 10; let n = arr.length let result = binarySearch(arr, 0, n - 1, x); (result == -1) ? document.write( \u0026#34;Element dizide değildir\u0026#34;) : document.write(`Element dizinde ${result}. sırada mevcut `); Iterative Python Javascript # X\u0026#39;in indexini döndürür, yoksa -1 döndürür def binarySearch(arr, l, r, x): while l \u0026lt;= r: mid = l + (r - l) // 2 # Eğer eleman ortada mevcutsa # kendine eşittir if arr[mid] == x: return mid # Eğer element ortanca değerden küçükse # sadece sol tarafta olabilir elif arr[mid] \u0026lt; x: l = mid + 1 # Bunun dışındaki durumlarda # sadece sağ tarafta olabilir else: r = mid - 1 # Element dizide yoktur return -1 # Tanımlamalar arr = [2, 3, 4, 10, 40] x = 10 # Fonksiyonu çağırma result = binarySearch(arr, 0, len(arr)-1, x) if result != -1: print(\u0026#34;Element dizinde %d. sırada mevcut\u0026#34; % result) else: print(\u0026#34;Element dizide değildir\u0026#34;) // X\u0026#39;in indexini döndürür, yoksa -1 döndürür function binarySearch(arr, x) { let l = 0; let r = arr.length - 1; let mid; while (r \u0026gt;= l) { mid = l + Math.floor((r - l) / 2); // Eğer eleman ortada mevcutsa // kendine eşittir if (arr[mid] == x) return mid; // Eğer element ortanca değerden küçükse // sadece sol tarafta olabilir if (arr[mid] \u0026gt; x) r = mid - 1; // Bunun dışındaki durumlarda // sadece sağ tarafta olabilir else l = mid + 1; } // Element dizide yoktur return -1; } arr =new Array(2, 3, 4, 10, 40); x = 10; n = arr.length; result = binarySearch(arr, x); (result == -1) ? document.write( \u0026#34;Element dizide değildir\u0026#34;) : document.write(`Element dizinde ${result}. sırada mevcut `); ","permalink":"https://omerfarukdemirel.com.tr/post/binary-search/","summary":"Binary Search Nedir? Binary Search her türlü dataset ile çalışabilen ve içerisindeki verinin indexini bulmamızı sağlayan akıllı bir algoritmadır.\nBüyük dizilerde doğrdan tek-tek yapılan kontrolden daha hızlı çalışır fakat dizinin küçükten büyüğe veya büyükten küçüğe doğru sıralı olması zorunludur, aksi halde çalışmayacaktır.\nBinary Search Nasıl Çalışır? Binary search her bir işlemde arama uzayını yarı yarıya indirmek üzerinde kuruludur. Temel mantığı şu şekildedir;\nDizinin tam orasında bulunan veriyi seçer ve bu veri üzerinden kontrol yapar.","title":"Binary Search"}]