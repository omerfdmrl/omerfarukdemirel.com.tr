[{"content":"Eklenti Nedir? JavaScript ile proje geliştirirken projelerin başkaları tarafından kolayca düzenlenebilmesini, geliştirilebilmesini isteyebilirsiniz. Örneğin Quill.js\u0026rsquo; i bilmeyenimiz yoktur; kendisi başarılı bir WYSIWYG editörüdür. Bu kütüphaneyi kullanırken eğer içine özellik eklemek istiyorsak kütüphanenin kendi kodlarını düzenlemeden, bize sağladığı sınırlar içerisinde istediğimiz eklentiyi kodlayabiliriz ve çok daha kullanışlı bir hale getirebiliriz. Kaldı ki Github\u0026rsquo;da geliştiriciler tarafından kodlanmış bir sürü eklenti mevcuttur.\nNot: Anlaşılmadıysa tarayıcınızdaki eklentileri düşünebilirsiniz. Normalde olmayan harika özellikleri tarayıcınıza eklemeyi sağlar.\nSizde projenize eklenti sistemini eklemek istiyorsanız bu makalede NodeJs ile nasıl eklenti sistemini yapabileceğimizi öğrenicez.\nProjeyi Kurma Şimdi ilk adımlarımız olarak boş bir proje oluşturalım. Bunun için aşağıdaki komutları kullanabiliriz;\nmkdir eklentili-nodejs-projem cd eklentili-nodejs-projem npm init -y npm i express Bu komutlar ile NodeJs projemizi oluşturmuş olucaz. index.js dosyasını kuralım ve express ile basit bir serveri oluşturalım.\nconst express = require(\u0026#39;express\u0026#39;); const EventEmitter = require(\u0026#39;events\u0026#39;); class App extends EventEmitter { constructor() { super(); this.server = express(); this.server.use(express.json()); } start() { this.server.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.send(\u0026#39;Hello World!\u0026#39;); }); this.server.listen(8080, () =\u0026gt; { console.log(\u0026#39;Server started on port 3000\u0026#39;) this.emit(\u0026#39;start\u0026#39;); }); } stop() { if (this.stopped) return; console.log(\u0026#39;Server stopped\u0026#39;); this.emit(\u0026#39;stop\u0026#39;); this.stopped = true; process.exit(); } } const app = new App(); app.start(); [\u0026#34;exit\u0026#34;, \u0026#34;SIGINT\u0026#34;, \u0026#34;SIGUSR1\u0026#34;, \u0026#34;SIGUSR2\u0026#34;, \u0026#34;SIGTERM\u0026#34;, \u0026#34;uncaughtException\u0026#34;].forEach(event =\u0026gt; { process.on(event, () =\u0026gt; app.stop()); }); İlk Eklentimiz İlk olarak başlamak için ufak bir eklenti kodlayalım. Bu eklentilerde 2 temel fonksiyon olucak; load ve unload. Load, eklentinin kurulum esnasında; Unload; eklentiyi durdururken çalışıcaktır.\nİlk eklentimiz Api\u0026rsquo;nin aldığı istek sayısını saymak için bir middleware görevi görücektir ve bir API route ekleyerek istek sayısını geri döndürebilecektir.\nconst fs = require(\u0026#39;fs\u0026#39;); let count = 0; function load(app) { try { count = +fs.readFileSync(\u0026#39;./counter.txt\u0026#39;); } catch (e) { console.log(\u0026#39;counter.txt not found. Starting from 0\u0026#39;); } app.server.use((req, res, next) =\u0026gt; { count++; next(); }); app.server.get(\u0026#39;/count\u0026#39;, (req, res) =\u0026gt; { res.send({ count }); }) } // İstek sayısını kaydet function unload(app) { fs.writeFileSync(\u0026#39;./counter.txt\u0026#39;, count); } module.exports = { load, unload }; Eklentileri Ekleme Şimdi de eklentileri sisteme ekleyeceğiz. Bunun için plugins.js isimli dosyayı kullanacağız.\nconst fs = require(\u0026#34;fs\u0026#34;); class Plugins { constructor(app) { super(); this.app = app; this.plugins = {}; } // Ayarlardaki eklentileri yükler async loadFromConfig(path=\u0026#39;./plugins.json\u0026#39;) { const plugins = JSON.parse(fs.readFileSync(path)).plugins; for (let plugin in plugins) { if (plugins[plugin].enabled) { this.load(plugin); } } } // Yüklenecek eklentinin yolunu (path) alır ve yükler async load(plugin) { const path = plugins[plugin]; try { const module = require(path); this.plugins[plugin] = module; await this.plugins[plugin].load(this.app); console.log(`Loaded plugin: \u0026#39;${plugin}\u0026#39;`); } catch (e) { console.log(`Failed to load \u0026#39;${plugin}\u0026#39;`) this.app.stop(); } } } module.exports = Plugins; Eklenmesini istediğimiz eklentileri saklamak için plugins.json isimli dosyayı kullanabiliriz.\n{ \u0026#34;counter\u0026#34;: \u0026#34;./counter.js\u0026#34; } Son olarak bu eklenti sistemini yazılımımıza eklemek için index.js dosyasını düzenleyelim.\nconst express = require(\u0026#39;express\u0026#39;); const Plugins = require(\u0026#39;./plugins\u0026#39;); class App { constructor() { super(); this.plugins = new Plugins(this); this.server = express(); this.server.use(express.json()); } async start() { await this.plugins.load(); this.server.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.send(\u0026#39;Hello World!\u0026#39;); }); this.server.listen(8080, () =\u0026gt; { console.log(\u0026#39;Server started on port 3000\u0026#39;) }); } stop() { if (this.stopped) return; console.log(\u0026#39;Server stopped\u0026#39;); this.stopped = true; process.exit(); } } const app = new App(); app.start(); [\u0026#34;exit\u0026#34;, \u0026#34;SIGINT\u0026#34;, \u0026#34;SIGUSR1\u0026#34;, \u0026#34;SIGUSR2\u0026#34;, \u0026#34;SIGTERM\u0026#34;, \u0026#34;uncaughtException\u0026#34;].forEach(event =\u0026gt; { process.on(event, () =\u0026gt; app.stop()); }); Eklentileri Durdurma Şimdi eklentilerimize eklediğimiz unload fonskiyonunu kullanalım. Bunu eklentimizi durdurmak için kullanıcaz.\nconst fs = require(\u0026#34;fs\u0026#34;); class Plugins { constructor(app) { super(); this.app = app; this.plugins = {}; } async loadFromConfig(path=\u0026#39;./plugins.json\u0026#39;) { const plugins = JSON.parse(fs.readFileSync(path)).plugins; for (let plugin in plugins) { if (plugins[plugin].enabled) { this.load(plugin); } } } async load(plugin) { const path = plugins[plugin]; try { const module = require(path); this.plugins[plugin] = module; await this.plugins[plugin].load(this.app); console.log(`Loaded plugin: \u0026#39;${plugin}\u0026#39;`); } catch (e) { console.log(`Failed to load \u0026#39;${plugin}\u0026#39;`) this.app.stop(); } } unload(plugin) { if (this.plugins[plugin]) { this.plugins[plugin].unload(); delete this.plugins[plugin]; console.log(`Unloaded plugin: \u0026#39;${plugin}\u0026#39;`); } } stop() { for (let plugin in this.plugins) { this.unload(plugin); } } } module.exports = Plugins; Güvenli olarak sistemdeki tüm eklentileri durdurmak için index.js dosyasındaki App sınıfına stop methodunu ekleyebiliriz.\nstop() { if (this.stopped) return; + this.plugins.stop(); console.log(\u0026#39;Server stopped\u0026#39;); this.stopped = true; process.exit(); } Güvenlik Bu sistem sadece sizin kodladığınız eklentiler eklentiler ile çalışıcaksa hiçbir sorun olmadan çalışacaktır. Fakat eğerki WordPress gibi kullanıcıların yükleyebildiği bir eklenti sistemi ile çalıştıracaksanız, güvenli değildir çünkü eklentiler tüm sistem özelliklerine erişim sağlayabilecektir. Bu tür bir durumda Hook\u0026rsquo;ları kullanmalısınız ve farklı bir eklenti sistemi oluşturmalısınız. Dilerseniz bunu da başka bir makalede anlatabilirim.\n","permalink":"https://omerfarukdemirel.com.tr/post/nodejs-eklenti-sistemi-kodlama/","summary":"Eklenti Nedir? JavaScript ile proje geliştirirken projelerin başkaları tarafından kolayca düzenlenebilmesini, geliştirilebilmesini isteyebilirsiniz. Örneğin Quill.js\u0026rsquo; i bilmeyenimiz yoktur; kendisi başarılı bir WYSIWYG editörüdür. Bu kütüphaneyi kullanırken eğer içine özellik eklemek istiyorsak kütüphanenin kendi kodlarını düzenlemeden, bize sağladığı sınırlar içerisinde istediğimiz eklentiyi kodlayabiliriz ve çok daha kullanışlı bir hale getirebiliriz. Kaldı ki Github\u0026rsquo;da geliştiriciler tarafından kodlanmış bir sürü eklenti mevcuttur.\nNot: Anlaşılmadıysa tarayıcınızdaki eklentileri düşünebilirsiniz. Normalde olmayan harika özellikleri tarayıcınıza eklemeyi sağlar.","title":"NodeJs Eklenti Sistemi Kodlama"},{"content":"İlk olarak i18n klasörümüzü oluşturup daha sonra içerisinde dil adı şeklinde .toml dosyalarımızı oluşturuyoruz. Yani demek istediğim tr.toml veya en.toml.\nDaha sonra bu dosyaların içerisine değerler veriyoruz örnek değerler aşağıdaki gibidir:\ntr.toml dosyası:\n[page_title] other = \u0026quot;Türkçe Sayfa\u0026quot; en.toml dosyası:\n[page_title] other = \u0026quot;English Home\u0026quot; Daha sonra bunu kullanmak istediğimiz yerde şu kodu kullanıyoruz:\n{{ i18n \u0026quot;page_title\u0026quot; }} Bu kod eğer EN sayfasındaysak en.toml dosyasındaki değeri eğer TR sayfasındaysak tr.toml dosyasındaki değeri yazdıracaktır.\n","permalink":"https://omerfarukdemirel.com.tr/post/hugo-i18-degisken-kullanimi/","summary":"İlk olarak i18n klasörümüzü oluşturup daha sonra içerisinde dil adı şeklinde .toml dosyalarımızı oluşturuyoruz. Yani demek istediğim tr.toml veya en.toml.\nDaha sonra bu dosyaların içerisine değerler veriyoruz örnek değerler aşağıdaki gibidir:\ntr.toml dosyası:\n[page_title] other = \u0026quot;Türkçe Sayfa\u0026quot; en.toml dosyası:\n[page_title] other = \u0026quot;English Home\u0026quot; Daha sonra bunu kullanmak istediğimiz yerde şu kodu kullanıyoruz:\n{{ i18n \u0026quot;page_title\u0026quot; }} Bu kod eğer EN sayfasındaysak en.toml dosyasındaki değeri eğer TR sayfasındaysak tr.toml dosyasındaki değeri yazdıracaktır.","title":"Hugo i18n Değişken Kullanımı"},{"content":"Static Klasörü Static klasöründe css, js ve img dosyalarını barındırabiliriz. Bu public_html mantığıyla çalışmakta, içerisine ne atarsak ana dizindeymiş gibi oluyor.\nContent Klasörü Content klasöründe web sitenin içerikleri yani .md dosyaları bulunmakta. Bu içerikleri gruplandırmak istersek içerisinde klasör oluşturabiliyoruz. Eğer Çok dil kullanıyorsak klasör isimleri ülke kodlarına göre olmalıdır.\nData Klasörü Data klasöründe başka sayfalarda kullanabileceğimiz veriler bulunmakta. Bu veriler .yml dosyası olarak tutulmakta ve dosya isimlerinin bir önemi yoktur.\ni18n Klasörü i18n klasöründe çok dilli özelliği aktif edince otomatik olarak çağırılacak dil dosyaları ve bu dosyaların içerisinde kelimeler, görseller ve bağlantılar bulunmaktadır. Bu veriler .yml dosyası olarak tutulmakta ve dosya isimlerinin ülke kodlarına göre olması gerekir.\nLayouts Klasörü Layouts klasöründe temanın parçalanmış dosyalarını, kısa kodları, özelliştirilmiş sayfaların şablonlarını barındırabiliriz. Bu veriler .html olarak tutulur.\nConfig Klasörü Config klasörü çok dilli web sitelerde birden fazla config dosyasını ayırmak için kullanılır.\nThemes Klasörü Themes klasörü birden fazla tema test etmek için temaların karışmamasını sağlayan klasördür. Bu klasör sayesinde birden fazla tema deneyip config.toml dosyasında tek satır kodla istediğimiz temayı sitede kullanabiliriz.\nArchetypes Klasörü Eğer konsoldan yeni bir markdown dosyası oluşturmak isterseniz, o oluşan dosyanın varsayılan değerlerini belirlediğimiz klasördür. Bu klasöre ayarları eklediğimizde artık konsoldan markdown dosyası oluşturursak bizim archetypes klasöründe belirdediğimiz ayarlarda oluşur.\n","permalink":"https://omerfarukdemirel.com.tr/post/hugo-klasor-yapisi/","summary":"Static Klasörü Static klasöründe css, js ve img dosyalarını barındırabiliriz. Bu public_html mantığıyla çalışmakta, içerisine ne atarsak ana dizindeymiş gibi oluyor.\nContent Klasörü Content klasöründe web sitenin içerikleri yani .md dosyaları bulunmakta. Bu içerikleri gruplandırmak istersek içerisinde klasör oluşturabiliyoruz. Eğer Çok dil kullanıyorsak klasör isimleri ülke kodlarına göre olmalıdır.\nData Klasörü Data klasöründe başka sayfalarda kullanabileceğimiz veriler bulunmakta. Bu veriler .yml dosyası olarak tutulmakta ve dosya isimlerinin bir önemi yoktur.","title":"Hugo Klasör Yapısı"},{"content":"Class Nedir? JavaScript prototip tabanlı bir dildir ve javascript\u0026rsquo;teki her nesnenin, nesne özelliklerini ve yöntemlerini genişletmek için kullanılabilecek [[Prototype]] adlı gizli bir dahili özelliği vardır.\nJavaScript geliştiricileri, object-orianted design pattern (nesne yönelimli bir tasarım modeli) taklit etmek için constructor fonksiyonlarını kullandılar.\nES6 yani EcmaScript 2015 ile birlikte Class\u0026rsquo;ları JavaScript\u0026rsquo;de kullanabilir hale geldik. Aslında zaten JavaScript\u0026rsquo;de var olan Class yapısını getirme sebeplerinden başlıcası diğer dillerin çoğunun sahip olması ve temiz, düzenli kod yazılmasını mümkün kılması.\nModule Design Pattern\u0026rsquo;i Anlamak JavaScript\u0026rsquo;de modüller belirli kod parçalarını diğer bileşenlerden bağımsız tutmak için kullanılır. Public (herkese açık) veya Private (gizli) olarak erişim seviyeleri belirlenebilir.\nModüller\u0026rsquo;de özel kapsamları kullanabilmek için Immediately-Invoked-Function-Expressions (IIFE - hemen çağırılan fonksiyon) olarak tanımlanmalıdır.\nImmediately-Invoked-Function-Expressions Nedir? Adından da anlaşılabileceği gibi fonksiyonun daha sonra çağırılması yerine tanımlanırken çağırılmasıdır.\nNormal IIFE function foo(){ return console.log(\u0026#39;bar\u0026#39;) } foo() (function(){ return console.log(\u0026#39;bar\u0026#39;) })() IIFE ile çağırılan fonksiyonların içerisindeki değişkenler dış dünya tarafında görülmez ve ulaşılamaz. Bu sayede özel kapsamlar kullanılabilir. Bir kere çalışıcak kodlar için kullanılmalıdır ve global yerine yerel değişkenlerle çalışacağı için kod performans açısından daha hızlı olur.\nModule Design Pattern\u0026rsquo;i Örnekleri IIFE\u0026rsquo;yi de anladığımıza göre örneklere geçebiliriz. Temel yapı olarak şu şekildedir;\n(function() { // private değişkenler veya fonksiyonlar tanımlanır return { // public değişken veya fonksiyonlar tanımlanır } })(); Yukarıdaki fonksiyon ile private ve public verilerimizi tanımlayabilriz. Şimdi biraz daha realistik örnek verelim.\nvar EmployeeDetails = (function(){ var name: \u0026#34;Ömer Faruk\u0026#34;; var age = 19; var designation = \u0026#34;Developer\u0026#34;, var salary = 10000; var calculateBonus = function(amount) { salary = salary + amount; } return { name: name, age: age, designation: designation, calculateBonus: calculateBonus } })() var userName = EmployeeDetails.calculateBonus(1000); Bu örneğe bakıcak olursak salary değişkeninin fonksiyonda kullanıldığını fakat return edilmediği için dışarıdan ulaşılamayacağını görebilirsiniz. calculateBonus fonksiyonunda ikramiyeyi hesaplarken salary değişkeni kullanılmaktadır. Bu değişken return edilmeyip private olarak tanımlandığı için dışarıdan erişilemez fakat fonksiyon içerisinde kullanılmaya devam edebilir.\nDikkat! Public edilen değişkenlerin bir kopyası oluşur ve bunlar dışarıya sunulur. Eğerki değişken sonradan değişicek olsa bile ilk halindeki klonuna dışarıdan ulaşırız. Değişkenlerin değerlerinin değiştirilmesi vya okunması için get veya set metodları kullanılmalıdır.\nClass\u0026rsquo;lar Aslında Fonksiyon! Şimdi bir sürü bilgi öğrendik fakat konunun daha iyi anlaşılabilmesi için gerekliydi. Yukarıdaki kodlara baktığınızda bir şeyi anımsatıyor mu? Class\u0026rsquo;lar. Class dediğimiz yapı aslında bir fonksiyondur ve Class tanımladığınız zaman aslında bir fonksiyon tanımlamış oluyorsunuz. Gelin şimdi inceleyelim;\nconst x = function() {} const y = class {} console.log(typeof x); // function console.log(typeof y); // function Yukarıdaki örnekte görebileceğiniz gibi ikisininde çeşidi aynı ve function.\nClass\u0026rsquo;ların Tanımlanması Class\u0026rsquo;lar birer fonksiyon ise Class\u0026rsquo;lar ile yapabildiğimiz her şeyi fonksiyonlar ile de yapabilmemiz gerekir. Class\u0026rsquo;larda kullandığımız özelliklerin fonksiyonlarda nasıl tanımlandığını inceleyelim.\nConstructor Class\u0026rsquo;ı çağırırken çalışan ve değişken tanımlamamızı sağlayan constructor fonksiyonunun nasıl çalıştığına bir bakalım;\nClass Fonksiyon class Hero { constructor(name, level) { this.name = name; this.level = level; } } function Hero(name, level) { this.name = name; this.level = level; } Metodlar Class\u0026rsquo;ların içerisinde tanımladığımız metodların fonksiyonlar ile nasıl tanımlandığına da bakalım;\nClass Fonksiyon class Hero { constructor(name, level) { this.name = name; this.level = level; } hi() { return `${this.name} merhaba diyor.`; } } function Hero(name, level) { this.name = name; this.level = level; } Hero.prototype.hi = function() { return `${this.name} merhaba diyor.`; } Extend Class\u0026rsquo;ların ve fonksiyonların avantajlı bir özelliği, üst öğeye dayalı olarak yeni bir nesne olarak geliştirilebilmesidir. Bu, benzer ancak bazı ek veya daha spesifik özelliklere ihtiyaç duyan nesneler için kodun tekrarlanmasını önler.\nAşağıdaki örnekte, SuperHero adlı daha spesifik bir Hero oluşturacağız ve call() kullanarak Hero özelliklerini atayacağız ve ek bir özellik ekleyeceğiz.\nClass Fonksiyon class SuperHero extends Hero { constructor(name, level, spell) { // Hero Class\u0026#39;ının constructorunu çağırma super(name, level); // Yeni özelliği ekle this.spell = spell; } } const ironman = new SuperHero(\u0026#39;Tony Stark\u0026#39;, 2, \u0026#39;Money\u0026#39;); function SuperHero(name, level, spell) { // Hero fonksiyonunun constructorunu çağırma Hero.call(this, name, level); // Yeni özelliği ekle this.spell = spell; } const superman = new SuperHero(\u0026#39;Clark Kent\u0026#39;, 9999, \u0026#39;Unlimited Power\u0026#39;); Kapanış Bu yazıda Class\u0026rsquo;lar ve fonksiyonların benzerliğini ve nasıl çalıştığını öğrenmiş olduk. Nasıl çalıştığını anlamak bir dilde uzmanlaşmak için çok önemlidir. Daha fazlası için takipte kalabilir, eğer yazıda eksik veya hata gördüyseniz Github üzerinden düzenleyebilirsiniz.\n","permalink":"https://omerfarukdemirel.com.tr/post/javascriptde-classlar-gercek-midir/","summary":"Class Nedir? JavaScript prototip tabanlı bir dildir ve javascript\u0026rsquo;teki her nesnenin, nesne özelliklerini ve yöntemlerini genişletmek için kullanılabilecek [[Prototype]] adlı gizli bir dahili özelliği vardır.\nJavaScript geliştiricileri, object-orianted design pattern (nesne yönelimli bir tasarım modeli) taklit etmek için constructor fonksiyonlarını kullandılar.\nES6 yani EcmaScript 2015 ile birlikte Class\u0026rsquo;ları JavaScript\u0026rsquo;de kullanabilir hale geldik. Aslında zaten JavaScript\u0026rsquo;de var olan Class yapısını getirme sebeplerinden başlıcası diğer dillerin çoğunun sahip olması ve temiz, düzenli kod yazılmasını mümkün kılması.","title":"Javascript'de Class'lar Gerçek Midir?"},{"content":"Binary Search Nedir? Binary Search her türlü dataset ile çalışabilen ve içerisindeki verinin indexini bulmamızı sağlayan akıllı bir algoritmadır.\nBüyük dizilerde doğrdan tek-tek yapılan kontrolden daha hızlı çalışır fakat dizinin küçükten büyüğe veya büyükten küçüğe doğru sıralı olması zorunludur, aksi halde çalışmayacaktır.\nBinary Search Nasıl Çalışır? Binary search her bir işlemde arama uzayını yarı yarıya indirmek üzerinde kuruludur. Temel mantığı şu şekildedir;\nDizinin tam orasında bulunan veriyi seçer ve bu veri üzerinden kontrol yapar. 3 farklı durum vardır; Seçilen değer aradığımız değere eşit ise aradığımız değer bulunmuştur. Değer geri döndürülür ve algoritma biter. Seçilen değer aradığımız değerden daha küçük ise aradığımız değer, seçtiğimiz verinin sol tarafındadır. Seçilen değer aradığımız değerden daha büyük ise aradığımız değer, seçtiğimiz verinin sağ tarafındadır. Yukarıdaki 2. veya 3. seçenekten biri gerçekleşmiş ise kümemizin diğer kısmını sileriz ve yarıya indirmiş oluruz. Ardından 1. adımı tekrardan uygularız ve aradığımız değeri bulana kadar devam ederiz. Aşağıdaki örnekte tek-tek yapılan kontrole kıyasla ne kadar hızlı olduğunu görebilirsiniz.\nŞimdi daha iyi anlamak için örnek yapacak olursak [-3,2,4,,4,9,12,34,42,102,157,180]\u0026lsquo;den oluşan veri setinden 42 sayısını bulmaya çalışalım;\n-3 2 4 4 9 12 34 42 102 157 180 -3 2 4 4 9 12 34 42 102 157 180 -3 2 4 4 9 12 34 42 102 157 180 -3 2 4 4 9 12 34 42 102 157 180 Kodlama Kodlamaya başlamadan önce aşağıdaki işlemleri bilmemiz gerekmektedir;\nZaman Karmaşıklığı: O(log n) Yardımcı Alan: O(1) Ortanca Değeri Bulma: en_yuksek + ( en_dusuk + en_yuksek ) / 2 Son maddede neden en_yuksek değer ile topladığımızı merak ediyor olabilirsiniz. Direkt olarak ( en_dusuk + en_yuksek ) / 2 de yapabilirdik fakat bu 100% doğruluk oranı vermeyecektir. Çünkü en düşük ve en yüksek değerlerden daha büyük değerleri aldığımızda başarısız olacaktır. Özellikle en düşük ve en yüksek değerin toplamı datasetimizdeki maximum pozitif değerden büyükse başarısız olacaktır. Sonuçta toplam değer negatif olur ve 2\u0026rsquo;ye bölündüğünde negatif olarak kalır.\nRecursive Python Javascript # X\u0026#39;in indexini döndürür, yoksa -1 döndürür def binarySearch(arr, l, r, x): # Temeli kontrol et if r \u0026gt;= l: mid = l + (r - l) // 2 # Eğer eleman ortada mevcutsa # kendine eşittir if arr[mid] == x: return mid # Eğer element ortanca değerden küçükse # sadece sol tarafta olabilir elif arr[mid] \u0026gt; x: return binarySearch(arr, l, mid-1, x) # Bunun dışındaki durumlarda # sadece sağ tarafta olabilir else: return binarySearch(arr, mid + 1, r, x) else: # Element dizide yoktur return -1 # Tanımlamalar arr = [2, 3, 4, 10, 40] x = 10 # Fonksiyonu çağırma result = binarySearch(arr, 0, len(arr)-1, x) if result != -1: print(\u0026#34;Element dizinde %d. sırada mevcut\u0026#34; % result) else: print(\u0026#34;Element dizide değildir\u0026#34;) // X\u0026#39;in indexini döndürür, yoksa -1 döndürür function binarySearch(arr, l, r, x){ if (r \u0026gt;= l) { let mid = l + Math.floor((r - l) / 2); // Eğer eleman ortada mevcutsa // kendine eşittir if (arr[mid] == x) return mid; // Eğer element ortanca değerden küçükse // sadece sol tarafta olabilir if (arr[mid] \u0026gt; x) return binarySearch(arr, l, mid - 1, x); // Bunun dışındaki durumlarda // sadece sağ tarafta olabilir return binarySearch(arr, mid + 1, r, x); } // Element dizide yoktur return -1; } let arr = [ 2, 3, 4, 10, 40 ]; let x = 10; let n = arr.length let result = binarySearch(arr, 0, n - 1, x); (result == -1) ? document.write( \u0026#34;Element dizide değildir\u0026#34;) : document.write(`Element dizinde ${result}. sırada mevcut `); Iterative Python Javascript # X\u0026#39;in indexini döndürür, yoksa -1 döndürür def binarySearch(arr, l, r, x): while l \u0026lt;= r: mid = l + (r - l) // 2 # Eğer eleman ortada mevcutsa # kendine eşittir if arr[mid] == x: return mid # Eğer element ortanca değerden küçükse # sadece sol tarafta olabilir elif arr[mid] \u0026lt; x: l = mid + 1 # Bunun dışındaki durumlarda # sadece sağ tarafta olabilir else: r = mid - 1 # Element dizide yoktur return -1 # Tanımlamalar arr = [2, 3, 4, 10, 40] x = 10 # Fonksiyonu çağırma result = binarySearch(arr, 0, len(arr)-1, x) if result != -1: print(\u0026#34;Element dizinde %d. sırada mevcut\u0026#34; % result) else: print(\u0026#34;Element dizide değildir\u0026#34;) // X\u0026#39;in indexini döndürür, yoksa -1 döndürür function binarySearch(arr, x) { let l = 0; let r = arr.length - 1; let mid; while (r \u0026gt;= l) { mid = l + Math.floor((r - l) / 2); // Eğer eleman ortada mevcutsa // kendine eşittir if (arr[mid] == x) return mid; // Eğer element ortanca değerden küçükse // sadece sol tarafta olabilir if (arr[mid] \u0026gt; x) r = mid - 1; // Bunun dışındaki durumlarda // sadece sağ tarafta olabilir else l = mid + 1; } // Element dizide yoktur return -1; } arr =new Array(2, 3, 4, 10, 40); x = 10; n = arr.length; result = binarySearch(arr, x); (result == -1) ? document.write( \u0026#34;Element dizide değildir\u0026#34;) : document.write(`Element dizinde ${result}. sırada mevcut `); ","permalink":"https://omerfarukdemirel.com.tr/post/binary-search/","summary":"Binary Search Nedir? Binary Search her türlü dataset ile çalışabilen ve içerisindeki verinin indexini bulmamızı sağlayan akıllı bir algoritmadır.\nBüyük dizilerde doğrdan tek-tek yapılan kontrolden daha hızlı çalışır fakat dizinin küçükten büyüğe veya büyükten küçüğe doğru sıralı olması zorunludur, aksi halde çalışmayacaktır.\nBinary Search Nasıl Çalışır? Binary search her bir işlemde arama uzayını yarı yarıya indirmek üzerinde kuruludur. Temel mantığı şu şekildedir;\nDizinin tam orasında bulunan veriyi seçer ve bu veri üzerinden kontrol yapar.","title":"Binary Search"}]